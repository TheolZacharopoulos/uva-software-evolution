<!DOCTYPE html>
<meta charset="utf-8">

<head>
<link rel="stylesheet" type="text/css" href="styles/style.css">
<head>

<body>
<script src="libs/d3.min.js"></script>
<script src="js/Consts.js"></script>
<script>

// Make a full circle
const cluster = d3.layout.cluster()
	    .size([DEGREES, innerRadius])
	    .sort(null)
	    .value(d => d.size);

const bundle = d3.layout.bundle();

const line = d3.svg.line.radial()
	    .interpolate("bundle")
	    .tension(TENSION)
	    .radius(d => d.y)
	    .angle(d => d.x / 180 * Math.PI);

// Setup dom elements
const svg = d3.select("body").append("svg")
    .attr("width", diameter)
    .attr("height", diameter)
  .append("g")
    .attr("transform", "translate(" + radius + "," + radius + ")");

var link = svg.append("g").selectAll(".link"),
    node = svg.append("g").selectAll(".node");

d3.json(DATA_FILE, readData);

// Read the data
function readData(error, data) {
	if (error) throw error;

	// extract data
	var clonePairs = data;

    var nodes = cluster.nodes(fileHierarchy(clonePairs)),
        links = fileClonePairs(nodes);

    // Contract the links between the nodes in the dom
    link = link
        .data(bundle(links))
      .enter().append("path")
        .each(clonePair => {
			clonePair.source = clonePair[0],
			clonePair.target = clonePair[clonePair.length - 1];
		})
        .attr("class", "link")
        .attr("d", line);

    // // Contract the nodes in the dom
    node = node
        .data(nodes.filter(n => !n.children))
      .enter().append("text")
        .attr("class", "node")
        .attr("dy", ".31em")
        .attr("transform", d => "rotate(" + (d.x - 90) + ")translate(" + (d.y + 8) + ",0)" + (d.x < 180 ? "" : "rotate(180)"))
        .style("text-anchor", d => d.x < 180 ? "start" : "end")
        .text(d => d.key)
        .on("mouseover", mouseovered)
        .on("mouseout", mouseouted);
}

function mouseovered(d) {
  node
      .each( n => n.target = n.source = false);

  link
      .classed("link--target", function(l) { if (l.target === d) return l.source.source = true; })
      .classed("link--source", function(l) { if (l.source === d) return l.target.target = true; })
    .filter(function(l) { return l.target === d || l.source === d; })
      .each(function() { this.parentNode.appendChild(this); });

  node
      .classed("node--target", n => n.target)
      .classed("node--source", n => n.source);
}

function mouseouted(d) {
  link
      .classed("link--target", false)
      .classed("link--source", false);

  node
      .classed("node--target", false)
      .classed("node--source", false);
}

d3.select(self.frameElement).style("height", diameter + "px");

// Lazily construct the files hierarchy from clonePairs.
function fileHierarchy(clonePairs) {
  var map = {};

  function find(name, data) {
    var node = map[name], i;

    if (!node) {

      node = map[name] = data || {name: name, children: []};
      if (name.length) {
        node.parent = find(name.substring(0, i = name.lastIndexOf(".")));
        node.parent.children.push(node);
        node.key = name.substring(i + 1);
      }
    }
    return node;
  }

  clonePairs.forEach(d => find(d.name, d));

  return map[""];
}

// Return a list of clone pairs for the given array of files.
function fileClonePairs(files) {
  var map = {},
      clones = [];

  // Compute a map from name to file.
  files.forEach(d => map[d.name] = d);

  // For each clone, construct a link from the source to target file.
  files.forEach(clonePair => {
    if (clonePair.imports) clonePair.imports.forEach(clone => {
      clones.push({source: map[clonePair.name], target: map[clone]});
    });
  });

  return clones;
}

</script>
